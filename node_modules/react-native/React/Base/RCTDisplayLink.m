/**
 * Copyright (c) 2015-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#import "RCTDisplayLink.h"

#import <Foundation/Foundation.h>
#if TARGET_OS_IPHONE
#import <QuartzCore/CADisplayLink.h>
#else
#import <CoreVideo/CVDisplayLink.h>
#endif

#import "RCTAssert.h"
#import "RCTBridgeModule.h"
#import "RCTFrameUpdate.h"
#import "RCTModuleData.h"
#import "RCTProfile.h"

#define RCTAssertRunLoop() \
  RCTAssert(_runLoop == [NSRunLoop currentRunLoop], \
  @"This method must be called on the CADisplayLink run loop")

#if !TARGET_OS_IPHONE
// This is the renderer output callback function
static CVReturn displayLinked(CVDisplayLinkRef displayLink,
                              const CVTimeStamp* now,
                              const CVTimeStamp* outputTime,
                              CVOptionFlags flagsIn,
                              CVOptionFlags* flagsOut,
                              void* displayLinkContext)
{
  __weak dispatch_source_t source = (__bridge dispatch_source_t)displayLinkContext;
  dispatch_source_merge_data(source, 1);
  return kCVReturnSuccess;
}
#endif

@implementation RCTDisplayLink
{
#if TARGET_OS_IPHONE
  CADisplayLink *_jsDisplayLink;
#else
  CVDisplayLinkRef _jsDisplayLink;
  dispatch_source_t _jsDisplaySource;
#endif
  NSMutableSet<RCTModuleData *> *_frameUpdateObservers;
  NSRunLoop *_runLoop;
}

- (instancetype)init
{
  if ((self = [super init])) {
    _frameUpdateObservers = [NSMutableSet new];
#if TARGET_OS_IPHONE
    _jsDisplayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(_jsThreadUpdate:)];
#else
    _jsDisplayLink = (__bridge CVDisplayLinkRef)(dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, dispatch_get_main_queue()));
    __block RCTDisplayLink* weakSelf = self;
    dispatch_source_set_event_handler(_jsDisplaySource, ^(){
      [weakSelf _jsThreadUpdate:weakSelf->_jsDisplayLink];
    });
    dispatch_resume((__bridge dispatch_object_t _Nonnull)(_jsDisplayLink));

    CVReturn cvReturn;
    // Create a display link capable of being used with all active displays
    cvReturn = CVDisplayLinkCreateWithActiveCGDisplays(&_jsDisplayLink);

    assert(cvReturn == kCVReturnSuccess);

    cvReturn = CVDisplayLinkSetOutputCallback(_jsDisplayLink, &displayLinked, (__bridge void*)_jsDisplaySource);

    assert(cvReturn == kCVReturnSuccess);

    cvReturn = CVDisplayLinkSetCurrentCGDisplay(_jsDisplayLink, CGMainDisplayID () );

    assert(cvReturn == kCVReturnSuccess);
#endif
  }

  return self;
}

- (void)registerModuleForFrameUpdates:(id<RCTBridgeModule>)module
                       withModuleData:(RCTModuleData *)moduleData
{
  if (![moduleData.moduleClass conformsToProtocol:@protocol(RCTFrameUpdateObserver)] ||
      [_frameUpdateObservers containsObject:moduleData]) {
    return;
  }

  [_frameUpdateObservers addObject:moduleData];

  // Don't access the module instance via moduleData, as this will cause deadlock
  id<RCTFrameUpdateObserver> observer = (id<RCTFrameUpdateObserver>)module;
  __weak typeof(self) weakSelf = self;
  observer.pauseCallback = ^{
    typeof(self) strongSelf = weakSelf;
    if (!strongSelf) {
      return;
    }

    CFRunLoopRef cfRunLoop = [strongSelf->_runLoop getCFRunLoop];
    if (!cfRunLoop) {
      return;
    }

    if ([NSRunLoop currentRunLoop] == strongSelf->_runLoop) {
      [weakSelf updateJSDisplayLinkState];
    } else {
      CFRunLoopPerformBlock(cfRunLoop, kCFRunLoopDefaultMode, ^{
        [weakSelf updateJSDisplayLinkState];
      });
      CFRunLoopWakeUp(cfRunLoop);
    }
  };

  // Assuming we're paused right now, we only need to update the display link's state
  // when the new observer is not paused. If it not paused, the observer will immediately
  // start receiving updates anyway.
  if (![observer isPaused] && _runLoop) {
    CFRunLoopPerformBlock([_runLoop getCFRunLoop], kCFRunLoopDefaultMode, ^{
      [self updateJSDisplayLinkState];
    });
  }
}

- (void)addToRunLoop:(NSRunLoop *)runLoop
{
  _runLoop = runLoop;
#if TARGET_OS_IPHONE
  [_jsDisplayLink addToRunLoop:runLoop forMode:NSRunLoopCommonModes];
#endif
}

- (void)invalidate
{
#if TARGET_OS_IPHONE
  [_jsDisplayLink invalidate];
#endif
}

- (void)dispatchBlock:(dispatch_block_t)block
                queue:(dispatch_queue_t)queue
{
  if (queue == RCTJSThread) {
    block();
  } else if (queue) {
    dispatch_async(queue, block);
  }
}

#if TARGET_OS_IPHONE
- (void)_jsThreadUpdate:(CADisplayLink *)displayLink
#else
- (void)_jsThreadUpdate:(CVDisplayLinkRef)displayLink
#endif
{
  RCTAssertRunLoop();

  RCT_PROFILE_BEGIN_EVENT(RCTProfileTagAlways, @"-[RCTDisplayLink _jsThreadUpdate:]", nil);

  RCTFrameUpdate *frameUpdate = [[RCTFrameUpdate alloc] initWithDisplayLink:displayLink];
  for (RCTModuleData *moduleData in _frameUpdateObservers) {
    id<RCTFrameUpdateObserver> observer = (id<RCTFrameUpdateObserver>)moduleData.instance;
    if (!observer.paused) {
      RCTProfileBeginFlowEvent();

      [self dispatchBlock:^{
        RCTProfileEndFlowEvent();
        [observer didUpdateFrame:frameUpdate];
      } queue:moduleData.methodQueue];
    }
  }

  [self updateJSDisplayLinkState];

  RCTProfileImmediateEvent(RCTProfileTagAlways, @"JS Thread Tick", displayLink.timestamp, 'g');

  RCT_PROFILE_END_EVENT(RCTProfileTagAlways, @"objc_call");
}

- (void)updateJSDisplayLinkState
{
  RCTAssertRunLoop();

  BOOL pauseDisplayLink = YES;
  for (RCTModuleData *moduleData in _frameUpdateObservers) {
    id<RCTFrameUpdateObserver> observer = (id<RCTFrameUpdateObserver>)moduleData.instance;
    if (!observer.paused) {
      pauseDisplayLink = NO;
      break;
    }
  }

#if TARGET_OS_IPHONE
  _jsDisplayLink.paused = pauseDisplayLink;
#else
  if (pauseDisplayLink) {
    CVDisplayLinkStop(_jsDisplayLink);
  } else {
    CVDisplayLinkStart(_jsDisplayLink);
  }
#endif
}

@end
